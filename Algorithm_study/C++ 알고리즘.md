# C++ 알고리즘



## 2.1 기본 형태

- **C++** 코드 기본 템플릿

  ```C++
  #include <bits/stdc++.h>
  // #include는 표준 라이브러리 전체를 포함시키는 g++ 컴파일러의 기능.
  // 이 경우, iostream, vector, algorithm 등의 라이브러리를 개별적으로 포함시키지 않아도 자동으로 사용 할 수 있다.
  using namespace std;
  // using 구문은 표준 라이브러리의 클래스 및 함수를 바로 사용할 수 있도록 하기 위한 선언문.
  // 예) std::cout -> cout 으로 바로 작성가능케 한다.
  int main(){
      // 이 부분에 풀이 작성
  }
  ```

### 2.1.1 입력과 출력

- 대부분의 대회에서 입력을 읽고 출력을 쓸 떄 표준 스트림을 사용한다.

- **C++**의 표준 스트림은 **cin**(입력), **cout**(출력) 이다. 물론 C 언어 함수인 **scanf**, **printf**도 사용 가능하다.

- 프로그램의 입력은 보통 공백 문자나 개행 문자로 구분된 문자열 또는 수로 이루어진다. 

  ```C++
  // 입력 파일
  // 123 456 monkey
  // 123      456 
  // monkey
  // 이러한 형태를 모두 읽어들일 수 있다.
  int a, b;
  sting x;
  cin >> a >> b >> x;
  ```

- 출력은 **cout** 스트림을 활용하면 된다.

  ```C++
  int a = 123, b = 456;
  string x = "monkey";
  cout << a << " " << b << " " << x << "\n"; // 123 456 monkey
  ```

- 간혹 입력과 출력이 프로그램의 병목이 될 때가 있다. 이러한 경우에는 코드 시작부분에 다음과 같은 코드를 삽입한다.

  ```C++
  ios::sync_with_stdio(0);
  cin.tie(0);
  ```

- 개행문자 "**\n**"이 **endl**보다 속도가 더 빠르다. 그 이유는 **endl**을 사용하면 명시적으로 flush(출력 버퍼 비우기)가 일어나기 때문이다.

- 만일 입력받는 데이터의 양을 사전에 알 수 없다면, 다음과 같은 형태의 반복문을 활용하면 된다.

  ```C++
  while (cin >> x){
      // 코드
  }
  // 입력에 포함된 원소를 하나하나씩 읽어 들이다가 더 이상 데이터가 남아 있지 않을 때 멈춘다.
  ```

- 몇몇 대회는 입력과 출력을 위해 파일을 사용한다. 

  ```C++
  freopen("input.txt", "r", stdin);
  freopen("output.txt", "w", stdout);
  ```

### 2.1.2 수를 처리하는 방법

1. **정수**
   - 경진 프로그래밍에서 가장 많이 사용되는 정수 자료형은 **int**이다.
   
   - **int**는 32bit 자료형이며, 범위는 -2<sup>31</sup> ~ 2<sup>31</sup> - 1 이다.

   - 만약 **int**로 부족하다면 64bit 자료형인 **long long**을 사용하면 된다.
   
   - **long long** 자료형을 사용할 때 자주 하는 실수가 있는데 코드 어딘가에서 **int** 자료형을 사용하는 실수가 빈번하게 일어난다.
   
     ```C++
     int a = 123456789;
     long long b = a*a; 
     // long long 자료형 b이지만 대입하는 a * a는 인트형이므로, 이상한 값이 나온다.
     cout << b << "\n"; // -1757895751
     long long c = (long long)a * a
     ```
   
2. **나머지 연산**

   - 문제의 답은 매우 큰 정수지만, 그 값의 **모듈로(modulo)** *m* 을 구하기만 하면 충분한 경우가 종종 있다.

   - *x*를 *m*으로 나눈 나머지를 *x* **mod** *m* 으로 나타낸다. **mod** 연산은 다음과 같은 성질이 있다.

       ```C++
       (a + b) mod m = (a mod m + b mod m) mod m
       (a - b) mod m = (a mod m - b mod m) mod m
       (a * b) mod m = (a mod m * b mod m) mod m
       // 매번 연산을 수행할 때 마다 나머지를 취해 연산을 해주면 된다.
       ```

3. **부동 소수점 실수**

   - **C++**의 부동 소수점 자료형 중 가장 유용한 것은 64bit **double** 이다. **g++** 컴파일러가 지원하는 확장 자료형인 80bit **long double**도 유용하다.

   - 문제에 답을 어느 정도의 정밀도로 구해야 하는지 나와 있다. 이에 맞춰 출력하는 방법은 다음과 같다.

     ```C++
     printf("%.9f\n", x); // x를 소수점 아래 9자리까지 출력
     ```

   - 부동 소수점 형태로 정확하게 표현할 수 없어서 오차가 생기는 실수가 존재한다.
   
     ```C++
     double x = 0.3 * 3 + 0.1; // x = 1 
     printf("%.20f\n", x); // 0.99999999999999988898
     // 값이 다르다.
     ```
   
   - 부동 소수점 실수를 **==** 연산자를 이용하여 비교하는 것은 매우 위험하다. 정밀도 오류로 인해 다르다는 결과가 나올 수 있기 때문이다. 좀 더 나은 방법은 두 실수의 차이가 **ε**보다 작을 때 서로 일치한다고 판단하는 것이다. 밑의 코드에선 **ε = 10<sup>-9</sup>** 이다.
   
     ```c++
     if (abs(a-b) < 1e-9) {
         // a와 b가 일치한다.
     }
     ```
     
   - 부동 소수점 실수는 부정확하지만 특정 범위 이하의 정수는 정확하게 표현 할 수 있다.
   
   - **double**을 사용하면 절댓값이 **2<sup>53</sup>**이하인 모든 정수를 정확하게 표현 할 수 있다.

### 2.1.3 코드 짧게 만들기

1. **자료형**

   - **typedef** 명령어를 이용하면 자료형의 이름을 좀 더 짧게 만들 수 있다. **long long**은 너무 길기 때문에 **ll**로 줄일 수 있다.

     ```C++
     typedef long long ll;
     ll a = 123456789; // long long a = 123456789;
     ll b = 987654321; // long long b = 987654321;
     ```

   - 복잡한 형태의 자료형에도 **typedef** 명령어를 사용할 수 있다. 예를 들어 다음 코드는 정수 벡터에 **vi**, 정수 두 개의 조합에 **pi**라는 이름을 붙인다.

     ```C++
     typedef vector<int> vi;
     typedef pair<int, int> pi;
     ```

2. **매크로**

   - 매크로는 코드를 컴파일 하기전에 코드에 포함된 특정 문자열을 다른 문자열로 치환하는 규칙을 의미한다.

   - **C++**에서는 **#define** 지시문을 이용하여 매크로를 정의할 수 있다.

     ```C++
     #define F first
     #define S second
     #define PB push_back
     #define MP make_pair
     
     v.PB(MP(y1, x1)); // v.push_back(make_pair(y1, x1));
     v.PB(MP(y2, x2)); // v.push_back(make_pair(y2, x2));
     int d = v[i].F+v[i].S; // int d = v[i].first + v[i].second
     ```

   - 매크로에 인자를 줄 수 있고, 이를 활용하여 반복문이나 그 밖의 구조문을 짧게 만들 수 있다.
   
     ```C++
     #define REP(i, a, b) for (int i = a; i <= b; i++)
     
     REP(i, 1, n){
         search(i);
     }
     // for (int i = 1; i <= n; i++){
         //search(i);
        // }
     ```
   
     
## 2.2 재귀적 알고리즘

- **재귀**를 활용하면 코드를 가독성있게 구현할 수 있다.

### 2.2.1 부분집합 생성하기

- 재귀를 활용하는 예로 원소가 n개인 집합의 모든 부분집합을 생성하는 알고리즘이 있다.

- {1, 2, 3}의 부분집합은 ∅, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}이다. 재귀 함수를 이용하면 이러한 모든 부분집합을 생성할 수 있다.

  ```C++
  vector<int> subset; // 이 배열에는 각 부분집합의 원소가 저장된다.
  
  void search(int k){
      if (k == n+1){
          // 부분집합을 처리한다.
      } else {
          subset.push_back(k);
          // k를 부분집합에 포함시킨다.
          search(k+1);
          subset.pop_back();
          // k를 부분집합에 포함시키지 않는다.
          search(k+1);
      }
  }
  ```

- **search** 함수의 인자가 *k* 일때, 원소 *k*를 부분집합(**subset**)에 포함할지 말지를 결정한다. 그리고 두 경우에 모두 인자를 *k+1*로 주고 함수를 재귀적으로 호출한다. 그러다 *k = n + 1*이 되면, 함수가 모든 원소를 처리했기 때문에 하나의 부분 집합이 완성된다.

### 2.2.2 부분집합 생성하기

